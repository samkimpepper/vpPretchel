# giftbug

# 자잘한 투두리스트
- ~~event, gift 패키지 제대로 나눠서 정리~~
- event 관련해서, 아직 이름이 profile로 남아있는 곳 수정
- NamedEntityGraph 적용할 곳 찾아서 적용
- payments 패키지 정리(아임포트, 오픈뱅킹으로 나눠서)
- SecurityContextHolder로 하지 말고, @CurrentUser 인터페이스 만들어서 씀
- 서비스에서 서비스 주입받아서 쓰는 것 왠지 문제일 것 같음 -> 이거 링크 걸어서 뭐 쓰셈
- (이건 고민 중) 컨트롤러에서 외래키 엔티티를 레포지토리로 찾아 서비스에게 전달하는 방식으로 수정 
- 테스트용 계정 만들기. test, test.

# 자잘하지 않은 투두리스트 
- (아임포트) 선물 펀딩 결제 환불
- (오픈뱅킹) 입금이체 결과 조회 api 테스트(테스트 api로는 강제로 입금이체를 실패하게 할 수 없음)
- (아임포트) merchant_uid를 우선 서버에게 할당받는데, 그 요청을 무제한적으로 보낼 수 있는 문제 해결
  - 지금 하고 있는 방법: 스케줄러로 매일 자정에 merchant_uid 빼고 모두 널인 데이터 삭제
  - N분동안 K번 이상 요청하지 못하게 하는 기능이 스프링에 있나? 
- 라이트하우스라는 것 써보기 


### 서비스에서 서비스 주입받아서 써도 되나
- 문제: 책임이 불분명하고 맡는 역할이 많음. 
- 해결책:
  1. 컨트롤러에서 서비스 호출 - 하나의 트랜잭션으로 못 묶음. 어 그러고보니.. 이렇게 하면 컨트롤러에서 엔티티를 다루게 됨
  2. 여러 서비스를 조합해서 쓰는 통합 서비스 따로 만들기

https://www.inflearn.com/questions/30618
요약
즉 엔티티를 어느 계층까지 허용할 것인가
서비스 계층에서만 쓰기 VS 모든 계층에서 쓸 수 있게 하기
(역시나..) 둘 다 장단점이 있음.

엔티티를 서비스 계층에서만 쓰기
이렇게 하는 이유는, 엔티티의 지연로딩이 가능한 범위 때문. 엔티티 지연로딩 하려면 영속성 컨텍스트가 필요함. 이 영속성 컨텍스트는
일반적으로 트랜잭션 범위에 맞춰야. 트잭 시작할 때 영컨 생성하고, 트잭 끝날 때 영컨도 종료되는 것. 
문제: 이렇게 하면 서비스 계층 넘어선 컨트롤러에서는 트잭이 끝나버려서 영컨도 종료되고. 더이상 지연로딩 못함. 그래서 엔티티를 서비스에서만 쓰는게 안전.
해결책이 있긴 하네: OSIV, OEIV라는 처음 듣는 기능으로 영컨의 생존 범위를 UI 계층까지 가져갈 수 있음. 
의존성에 대해: 컨트롤러 계층만 도메인 모델 모른다고 해서 큰 이득을 얻진 못함. (신기하다)
개인적 결론: 기본적으로는 모두 도메인 모델 쓸 수 있게 실용적인 방향으로., 프젝이 커지고 성능 중요해지면 그때 OSIV 쓰지 못하게 함. 
그럼 UI 계층에선 지연로딩 어려워서 엔티티 사용 비중 줄어들고. 그래도 간단한 엔티티는 직접 조회해서 처리함.

딱딱한방식: DTO 많이만들고. DTO 변환도 많이 해야됨. 프젝 규모크면 고려할만함. 
이미 대부분 계층이 엔티티에 의존하는데 컨트롤러에서 단순히 엔티티 모른다고 해서 얻는 이점이 없다고? 아하. 그래도 엔티티를 api로 외부 공개하는 건 좋지 않다.

